---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# cwswatinput

<!-- badges: start -->
<!-- badges: end -->

cwswatinput (Climate & Weater SWAT input) is an open-source R package for preparing weather and climate data for the Soil & Water Assessment Tool (SWAT) input format.

## Installation

You can install the development version from GitHub with:

``` r
# install.packages("devtools")
devtools::install_github("swatufmt/cwswatinput")
```


```{r example}
library(cwswatinput)
## basic example code
```



```{r include=FALSE}
# o caminho dos arquivos
base_path <- "/media/reginal/Dados/transition/SWAT_UFMT/raw_data_cwswatinput_test"


era5land_2018 <- file.path(base_path, "ERA5-Land_data/Y2018.nc")
amSul_path <- file.path(base_path, "ERA5-Land_data/2019OneVariableAmSul.nc")
global_path <- file.path(base_path, "ERA5-Land_data/2019OneVariableGlobal.nc")
imerg_path <- file.path(base_path, "imerg_data/imerg_20000601.nc4")
dem_path <- file.path(base_path, "topodata/CBSL_mosaico_wgs84.tif")
bassin_path <- file.path(base_path, "shapefiles/cba_slc.shp")
```

# Rotinas para dados NetCDF ou raster

A ideia aqui consiste em extrair séries de dados de uma variável para cada pixel de uma área de estudo. Os produtos climáticos são disponibilizados em sites como [Climate Change Service](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land?tab=overview), [GES DISC](https://disc.gsfc.nasa.gov/datasets/GPM_3IMERGDF_06/summary?keywords="IMERG%20final"), [PERSIANN-CCS](https://chrsdata.eng.uci.edu/). Esses dados são disponibilizados em formato de raster(.tif) ou em formato de netcdf _(um formato muito utilizado para disponibilizar séries temporais de dados)_. Cada plataforma disponibiliza em seu site mais detalhes sobre os produtos disponibilizados e a forma correta para baixá-los.
Esses dados para serem utilizados dentro do SWAT precisam ser extraídos para um formato especifico em tabelas. Para facilitar, o pacote `cwswatinput` disponibiliza, por meio de funções, formas automatizadas da extração uma vez baixados.

## Passo a passo:

###### 1. Informar o caminho onde o arquivo se encontra
```{r}
era5land_2017 <- file.path(base_path, "ERA5-Land_data/Y2017.nc")
```

###### 2. Verificar as variaveis presentes no arquivo

```{r}
#verificar as variáveis presentes nos arquivos ncdf baixados
var_name <- names(ncdf4::nc_open(era5land_2017)$var)
var_name
```

Este arquivo por exemplo contem 6 variáveis

###### 3. Criar um raster multilayer com o arquivo, escolhendo uma variavel desejada entre as mostradas em var_name

```{r}
# carregando um arquivo ncdf e transformando-os em raster
# para um ncdf
one_brick <- raster::brick(era5land_2018,
                           varname = "uas")[[1:3]]
one_brick
```

> Os mesmos passos são válidos para dados de entrada como raster(.tif) uma vez que a partir deste passo estamos mexendo com rasters vindo da transformação dos netcdf. Os rasters podem ser importados e juntados para arquivos multilayer por meio das funções (raster::brick ou raster::stack).

> Alguns arquivos netcdf vem de uma forma invertida latitude com longitude, ao transformá-los para raster simplesmente importando não resolve e comprometa todo o processo. Neste caso `cwswatinput` tem a função `ncdf2raster()` que faz essa transformação.

###### 3.1 Caso forem varios arquivos, pode se criar uma lista raster multilayer

```{r}
# para carregar vários arquivos de ncdf para um lista
# quando for vários arquivos ao mesmo tempo
list_brick <- lapply(list(era5land_2017, era5land_2018),
                     raster::brick,
                     varname = "uas") |> lapply(\(x) (x[[1:3]]))
list_brick
```


###### 4. Criar um arquivo contendo o caminho dos pixels que caem dentro da área de estudo e a elevavão corespondente

```{r}
study_area <- study_area_records(raster = one_brick[[1]], # raster de exemplo, dos mesmos que serão extraídos os dados
                                 watershed = bassin_path, # shapefile par a delimitação da área de estudo
                                 DEM = dem_path) #raster de elevação para extrair a elevação de dada pixel
```

Resultado:
```{r}
knitr::kable(study_area[1:10, ])
```

###### 5. Com a tabela sobre a area de estudo, esta função cria a tabela master para cada variavel contida nos arquivos ncdf, basta informa o nome da variavel.

```{r}
mainFile <- mainInput_var(study_area = study_area,
                          var_name = "uas")

```

Resultado:
```{r}
knitr::kable(mainFile[1:10, ])
```

> Para ncdf com muitas variaveis é preciso ciar uma tabela master par cada uma das variaveis.


###### 6. Extrair os dados e guardar em uma tabela

Esta função faz a extração dos dados de um raster multilayer e guarda em uma tabela. A tabela criada contem duas colunas (values) que guarda os valores extraídos na mesma ordem dos ID e (layer_name) guardando o nome de cada layer extraído (geralmente é a data).


```{r}
tbls <- raster2vec(rasterbrick = one_brick,
                   study_area = study_area)
```

Resultado:
```{r}
knitr::kable(tbls[1:10, ])
```


A tabela pode ser valva com essas linhas:
```{r
# este arquivo pode ser salvo como tabelas individuais como:
data.table::fwrite(tbls,
                   "o_caminho/minha_tabela.csv",
                   row.names = TRUE)
```


###### 6.1 Quando varios netcdf constituem a mesma série é precisa criar um lista de rasters. A função `raster2vec` precisa ser iterada sobre cada um deles. O resultado é uma lista de tabela, cuja cada uma representa um arquivo.


```{r}
tbls1 <- lapply(list_brick, raster2vec, study_area)

```


As tabelas podem ser valvas com essas linhas:
```{r
# este arquivo pode ser salvo como tabelas individuais como:
data.table::fwrite(do.call(rbind, tbls1),
                   "o_caminho/minha_tabela.csv",
                   row.names = TRUE)
```



###### 7. Tendo uma tabela por arquivo, esta funcão transforma essa tabela em uma lista nomeada de séries por pixel. Ele recebe um vetor com os nomes para cada arquivo. Este vetor deve conter o mesmo tamanho que a quantidade pixel com valor. O nome da coluna deve ser a primeira data da série.


```{r message=FALSE, warning=FALSE}
cell_tables <-  layerValues2pixel(layer_values = tbls,
                                  tb_name = mainFile$NAME,
                                  col_name = "20170101")
# cell_tables1 <-  layerValues2pixel(layer_values = do.call(rbind, tbls1),
#                                   tb_name = mainFile$NAME,
#                                   col_name = "20170101")
```


Resultado:
```{r}
knitr::kable(cell_tables)
```




## Rotinas para dados de estações em uma área especifica

```{r include=FALSE}
pasta_estcoes <- system.file("extdata/pcp_stations", package = "cwswatinput")

estacoes <- list.files(pasta_estcoes, full.names = TRUE)

```


Arquivos dentro de uma pasta após a coleta:
```{r}
list.files(pasta_estcoes)
```

A pasta é composta por arquivos da série para cada estão e um arquivo master:

Exemplos:

- Uma serie para cada estação, onde o nome da coluna é a primeira data da série `p-1553003.txt`
```{r echo=FALSE}
read.csv(estacoes[1])
```


- Um arquivo master contendo os nomes as coordenadas e a elevação de cada estação `pcp.txt`
```{r echo=FALSE}
read.csv(estacoes[15])
```


Esta função pega as séries  de todos os pontos/estações e cria uma tabela única para cada dia

```{r}
dados_diarios <- point_to_daily(my_folder = pasta_estcoes,
                         var_pattern = "p-",
                         main_pattern = "pcp",
                         start_date = "20020101",
                         end_date = "20020120",
                         interval = "day",
                         na_value = -99,
                         negatif_number = TRUE,
                         prefix = "day_")
dados_diarios[1] # exemplo de uma tabela
```


As tabelas diárias podem ser salvas com a função `save_daily_tbl`do pacote `cwswatinput`, por favor olhe para documentação da função.




```{r include=FALSE}
pasta_dados_diarios <- system.file("extdata/ts_input", package = "cwswatinput")

centroides_path <- system.file("extdata/sl_centroides/Centroide_watershed_grau.shp",
                          package = "cwswatinput")

bassin_path <- system.file("extdata/sl_bassin/sl_bassin_limit.shp",
                           package = "cwswatinput")
```


Os centroides
```{r}
sf::read_sf(centroides_path)
```


Esta função faz a interpolação por meio do método trend surface para os pontos indicados por meio de um shapefile contendo os pontos desejados.

```{r}
serie_pontos <- ts_to_point(my_folder = pasta_dados_diarios,
                      targeted_points_path = centroides_path,
                      poly_degree = 2)

serie_pontos[1]
```



Esta função cria uma tabela master para swat input para os dados interpolados

```{r}
varMain_creator(targeted_points_path = centroides_path,
                var_name = "pcp",
                col_elev = "Elev")
```



Esta função interpola os pontos de entrada para uma área inteira e cria um raster para cada dia
```{r}
raster_interpolated <- ts_to_area(my_folder = pasta_dados_diarios,
           bassin_limit_path = bassin_path,
           poly_degree = 2,
           resolution = 0.01)

raster_interpolated
```


Para verificação, uma camada pode ser plotada com ajuda do pacote `tmap` como segue abaixo, e adicionando ao raster interpolado os pontos de observação que foram interpolados.

```{r}
tmap::tm_shape(raster_interpolated[[1]]) +
  tmap::tm_raster(title = "Precipitação Estimada \n Trend Surface",
                  midpoint = NA,
                  n = 15, palette = "-RdBu",
                  style = c("cat", "fixed", "sd", "equal", "pretty", "quantile",
                            "kmeans", "hclust", "bclust", "fisher",
                            "dpih", "headtails")[7]) +
  tmap::tm_shape(sf::read_sf(bassin_path)) +
  tmap::tm_borders(col = "red") +
  tmap::tm_shape(sf::st_as_sf(as.data.frame(dados_diarios[[1]]), coords = c("LONG", "LAT"),
                              crs = "+proj=longlat +datum=WGS84 +no_defs")) +
  tmap::tm_text(text = "pcp", just = c(-0.5, 0), size = .8) +
  tmap::tm_dots(shape = 1,
                col = "blue",
                size = "pcp",
                title.size = "Precipitação Observada em Campo") +
  tmap::tm_legend(legend.outside = TRUE) +
  tmap::tm_compass(type = "arrow", position = c(0.08,0.1), size = 2) +
  tmap::tm_scale_bar(text.size = .5,
                     position = c(0.01, 0),
  )

```



```{r eval=FALSE, include=FALSE}
map_ts_poly2
```

<br><br><br><br>

A documentação das funções criadas está disponivel e acessivel via `? nome da função`


